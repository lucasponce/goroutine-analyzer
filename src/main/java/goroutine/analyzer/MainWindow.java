package goroutine.analyzer;

import com.intellij.uiDesigner.core.GridConstraints;
import com.intellij.uiDesigner.core.GridLayoutManager;

import javax.swing.*;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.util.*;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

public class MainWindow {
    private final GoroutinesTreeModel treeModel = new GoroutinesTreeModel();

    private JFrame frame;
    private JPanel mainFrame;
    private JTree routines;
    private JTextPane stackDisplay;

    private final SimpleAttributeSet headerStyle;
    private final SimpleAttributeSet bodyStyle;

    // Fine granularity font personalization
    private enum FontComponents {
        CHOOSER, ITEM, LOAD, MAIN_MENU, MENU, QUIT, ROUTINES
    } ;
    private final Font mainFont = new Font("Courier", Font.PLAIN, 30);
    private final Map<FontComponents, Font> fonts = new EnumMap<>(Map.of(
          FontComponents.CHOOSER, mainFont,
          FontComponents.ITEM, mainFont,
          FontComponents.LOAD, mainFont,
          FontComponents.MAIN_MENU, mainFont,
          FontComponents.MENU, mainFont,
          FontComponents.QUIT, mainFont,
          FontComponents.ROUTINES, mainFont
    ));

    private File lastDir = null;
    {
        headerStyle = new SimpleAttributeSet();
        StyleConstants.setFontFamily(headerStyle, "Courier");
        StyleConstants.setFontSize(headerStyle, 24);
        StyleConstants.setBold(headerStyle, true);

        bodyStyle = new SimpleAttributeSet();
        StyleConstants.setFontFamily(bodyStyle, "Courier");
        StyleConstants.setFontSize(bodyStyle, 24);
        StyleConstants.setBold(bodyStyle, false);
        loadLastDir();
    }

    private void loadLastDir() {
        var prefs = Preferences.userNodeForPackage(MainWindow.class);
        var lastDirName = prefs.get("last.dir", null);
        if (lastDirName != null) {
            lastDir = new File(lastDirName);
        }
    }

    private void setLastDir(File lastDir) {
        var prefs = Preferences.userNodeForPackage(MainWindow.class);
        prefs.put("last.dir", lastDir.getAbsolutePath());
        try {
            prefs.sync();
        } catch (BackingStoreException e) {
            e.printStackTrace();
        }
    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        mainFrame = new JPanel();
        mainFrame.setLayout(new GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        final JSplitPane splitPane1 = new JSplitPane();
        mainFrame.add(splitPane1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(1024, 768), null, 0, false));
        final JScrollPane scrollPane1 = new JScrollPane();
        scrollPane1.setMinimumSize(new Dimension(300, 15));
        splitPane1.setLeftComponent(scrollPane1);
        routines = new JTree();
        routines.setRootVisible(false);
        scrollPane1.setViewportView(routines);
        final JScrollPane scrollPane2 = new JScrollPane();
        splitPane1.setRightComponent(scrollPane2);
        stackDisplay = new JTextPane();
        scrollPane2.setViewportView(stackDisplay);
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return mainFrame;
    }

    private class ElementSelectionListener implements TreeSelectionListener {
        Set<TreeElement> selected = new HashSet<>();

        @Override
        public void valueChanged(TreeSelectionEvent event) {
            var paths = event.getPaths();
            for (var i = 0; i < paths.length; i++) {
                var path = paths[i];
                var elem = (TreeElement) path.getLastPathComponent();
                if (event.isAddedPath(i)) {
                    selected.add(elem);
                } else {
                    selected.remove(elem);
                }
            }

            var stacks = new TreeSet<Stack>();
            for (var elem : selected) {
                if (!(elem instanceof StackDump) && !(elem instanceof Root)) {
                    elem.addStacks(stacks);
                }
            }

            var doc = stackDisplay.getDocument();
            try {
                doc.remove(0, doc.getLength());
                var count = 0;
                var maxCount = 250;
                for (var stack : stacks) {
                    doc.insertString(doc.getLength(), stack.header.header + "\n", headerStyle);
                    for (var elem : stack.elements) {
                        doc.insertString(doc.getLength(), elem.codeLine + "\n", bodyStyle);
                        doc.insertString(doc.getLength(), elem.sourceLine + "\n", bodyStyle);
                    }
                    doc.insertString(doc.getLength(), "\n", headerStyle);
                    if (count++ > maxCount) {
                        break;
                    }
                }
                if (stacks.size() > maxCount) {
                    doc.insertString(doc.getLength(), "\nTOO MANY STACKS: stopping after 250\n", headerStyle);
                }
                stackDisplay.setCaretPosition(0);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void loadFile() {
        final var chooser = new JFileChooser();
        if (lastDir != null) {
            chooser.setCurrentDirectory(lastDir);
        }
        chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        chooser.setMultiSelectionEnabled(true);

        getFirstJList(chooser).setFont(fonts.get(FontComponents.CHOOSER));

        var result = chooser.showOpenDialog(frame);
        System.out.println("result: " + result);
        if (result == JFileChooser.APPROVE_OPTION) {
            ForkJoinPool.commonPool().execute(() -> {
                try {
                    var files = chooser.getSelectedFiles();
                    if (files.length > 0) {
                        lastDir = files[0].getParentFile();
                        setLastDir(lastDir);
                    }
                    treeModel.openFiles(files);
                } catch (Exception e) {
                    e.printStackTrace();
                    SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(null, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE));
                }
            });
        }
    }

    private JMenuBar initMenuBar() {
        JMenuBar menuBar = new JMenuBar();
        JMenu mainMenu = new JMenu("File");
        mainMenu.setFont(fonts.get(FontComponents.MAIN_MENU));

        JMenuItem load = new JMenuItem("Load");
        load.setFont(fonts.get(FontComponents.LOAD));
        load.addActionListener(actionEvent -> loadFile());

        JMenuItem quit = new JMenuItem("Quit");
        quit.setFont(fonts.get(FontComponents.QUIT));
        quit.addActionListener(actionEvent -> System.exit(0));

        mainMenu.add(load);
        mainMenu.add(quit);

        menuBar.add(mainMenu);
        return menuBar;
    }

    class TreeMouseListener extends MouseAdapter {
        @Override
        public void mouseClicked(MouseEvent e) {
            if (!SwingUtilities.isRightMouseButton(e)) {
                return;
            }

            // If nothing is selected
            //     and we click somewhere that's not an element, don't do anything
            //     and we click on an element, act on that element
            // If something is selected
            //     and we click somewhere not on an element, act on selected elements
            //     and we clock on an element
            //         and the clicked element is not selected, act on the clicked element
            //         and the clicked element is selected, act on all selected elements
            var actions = new TreeMap<String, List<ContextAction>>();

            var first = true;
            var paths = routines.getSelectionPaths();
            var clickedPath = routines.getPathForLocation(e.getX(),e.getY());

            if (clickedPath != null && paths != null) {
                if (!Arrays.stream(paths).anyMatch( treePath -> treePath.equals(clickedPath))) {
                    paths = new TreePath[]{clickedPath};
                }
            }

            if (paths == null) {
                if (clickedPath != null) {
                    paths = new TreePath[]{clickedPath};
                } else {
                    return;
                }
            }

            for (var path : paths) {
                var elem = (TreeElement) path.getLastPathComponent();
                if (first) {
                    for (var action : elem.getContextActions()) {
                        var list = new ArrayList<ContextAction>();
                        list.add(action);
                        actions.put(action.label, list);
                    }
                } else {
                    for (var action : elem.getContextActions()) {
                        var list = actions.get(action.label);
                        if (list != null) {
                            list.add(action);
                        }
                    }
                }
                first = false;
            }

            var effectivePaths = paths;
            actions.entrySet().removeIf(entry -> entry.getValue().size() != effectivePaths.length);

            if (actions.isEmpty()) {
                return;
            }

            JPopupMenu menu = new JPopupMenu();
            menu.setFont(fonts.get(FontComponents.MENU));
            for (var entry : actions.entrySet()) {
                JMenuItem item = new JMenuItem(entry.getKey());
                item.setFont(fonts.get(FontComponents.ITEM));
                item.addActionListener(event -> SwingUtilities.invokeLater(() -> {
                    for (var contextAction : entry.getValue()) {
                        contextAction.action.execute(result -> {
                        if (result != null) {
                            SwingUtilities.invokeLater(() -> {
                                treeModel.handleChanges(result);
                                var focusPath = result.focus.getPath();
                                var treePath = new TreePath(focusPath);
                                if (result.expandFocus) {
                                    routines.expandPath(treePath);
                                } else {
                                    routines.expandPath(treePath.getParentPath());
                                }
                                routines.setSelectionPath(treePath);
                            });
                        }
                        });
                    }
                }));
                menu.add(item);
            }
            menu.show(routines, e.getX(), e.getY());
        }
    }

    private void init() {
        routines.setModel(treeModel);
        routines.setFont(fonts.get(FontComponents.ROUTINES));
        routines.setExpandsSelectedPaths(true);
        routines.addTreeSelectionListener(new ElementSelectionListener());
        routines.setShowsRootHandles(true);
        routines.addMouseListener(new TreeMouseListener());

        frame = new JFrame("Goroutine Analyzer");
        frame.setJMenuBar(initMenuBar());
        frame.setContentPane(mainFrame);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }

    //Obtains the (first) JList which is found inside the component/container:
    public static JList getFirstJList(final Component component) {
        if (component instanceof JList)
            return (JList) component;
        if (component instanceof Container)
            for (int i=0; i<((Container)component).getComponentCount(); ++i) {
                final JList list = getFirstJList(((Container)component).getComponent(i));
                if (list != null)
                    return list;
            }
        return null;
        //As you can see, it's a bit lazy hack, which has to run for every JFileChooser once at start-up.
    }

    public static void main(String[] args) {
        MainWindow mainWindow = new MainWindow();
        mainWindow.init();
    }
}